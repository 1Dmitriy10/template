import { defineConfig } from 'vite';
import handlebars from 'vite-plugin-handlebars';
import path from 'path';
import fs from 'fs';
import sharp from 'sharp';
import tailwindcss from '@tailwindcss/vite';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—ä–µ–∫—Ç input –¥–ª—è Rollup
const rollupInputs = {
  –ì–ª–∞–≤–Ω–∞—è: path.resolve(__dirname, 'src/html/index.html'),
  ui_kit: path.resolve(__dirname, 'src/html/ui-kit.html'),
  error: path.resolve(__dirname, 'src/html/404.html'),
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ JS —Ñ–∞–π–ª (–í–´–ó–´–í–ê–ï–ú –°–†–ê–ó–£)
function exportInputsToFile() {
  try {
    const exportPath = path.resolve(__dirname, 'src/js/libs/rollup-inputs.js');
    
    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    const exportDir = path.dirname(exportPath);
    if (!fs.existsSync(exportDir)) {
      fs.mkdirSync(exportDir, { recursive: true });
    }

    // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–º–∏ –ø—É—Ç—è–º–∏ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    const relativePaths = Object.fromEntries(
      Object.entries(rollupInputs).map(([key, absolutePath]) => [
        key, 
        path.relative(path.resolve(__dirname, 'src'), absolutePath)
      ])
    );

    const content = `// Auto-generated from vite.config.js
// Generated on: ${new Date().toISOString()}
// DO NOT EDIT THIS FILE MANUALLY

/**
 * Rollup input configuration for Vite build
 * Contains absolute paths to HTML entry points
 */
export const rollupInputs = ${JSON.stringify(rollupInputs, null, 2)};

/**
 * Relative paths from src directory
 * Useful for navigation within the project
 */
export const relativePaths = ${JSON.stringify(relativePaths, null, 2)};

/**
 * List of available page keys
 */
export const pageKeys = ${JSON.stringify(Object.keys(rollupInputs), null, 2)};

/**
 * Get the path for a specific page
 * @param {string} pageKey - Key of the page (index, ui_kit, error, etc.)
 * @returns {string|null} Absolute path or null if not found
 */
export function getPagePath(pageKey) {
  return rollupInputs[pageKey] || null;
}

/**
 * Get the relative path for a specific page
 * @param {string} pageKey - Key of the page (index, ui_kit, error, etc.)
 * @returns {string|null} Relative path from src directory or null if not found
 */
export function getPageRelativePath(pageKey) {
  return relativePaths[pageKey] || null;
}

/**
 * Check if a page key exists
 * @param {string} pageKey - Key to check
 * @returns {boolean} True if the page exists
 */
export function hasPage(pageKey) {
  return pageKey in rollupInputs;
}

export default rollupInputs;
`;

    fs.writeFileSync(exportPath, content);
    console.log('üìÅ Rollup inputs exported to: src/js/libs/rollup-inputs.js');
    console.log('üìã Available pages:', Object.keys(rollupInputs));
    
  } catch (error) {
    console.error('‚ùå Error exporting rollup inputs:', error);
  }
}

// –í–´–ó–´–í–ê–ï–ú –§–£–ù–ö–¶–ò–Æ –≠–ö–°–ü–û–†–¢–ê –°–†–ê–ó–£ –ñ–ï
exportInputsToFile();

// –•–µ–ª–ø–µ—Ä –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–µ—Å–∞ —à—Ä–∏—Ñ—Ç–∞
function getFontWeight(style) {
  const weights = {
    'thin': 100,
    'extralight': 200,
    'light': 300,
    'regular': 400,
    'normal': 400,
    'medium': 500,
    'semibold': 600,
    'bold': 700,
    'extrabold': 800,
    'black': 900
  };
  
  return weights[style.toLowerCase()] || 400;
}

// –•–µ–ª–ø–µ—Ä –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ–æ—Ä–º–∞—Ç–∞
function getFormat(ext) {
  const formats = {
    'woff2': 'woff2',
    'woff': 'woff',
    'ttf': 'truetype',
    'otf': 'opentype'
  };
  
  return formats[ext] || ext;
}

// ‚úÖ –ü–†–û–°–¢–û–ô –ü–õ–ê–ì–ò–ù –î–õ–Ø –ó–ê–ú–ï–ù–´ CSS –°–°–´–õ–ö–ò
const simpleAsyncCSSPlugin = () => {
  return {
    name: 'simple-async-css',
    apply: 'build',
    
    transformIndexHtml(html) {
      console.log('üéØ Making CSS async...');
      
      // –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é
      return html.replace(
        /<link rel="stylesheet"[^>]*?href="([^"]*?main[^"]*?\.css)"[^>]*?>/i,
        `<!-- CSS loaded asynchronously -->
<link rel="preload" href="$1" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="$1"></noscript>
<script>
  // Fallback for async CSS loading
  document.addEventListener('DOMContentLoaded', function() {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = '$1';
    document.head.appendChild(link);
  });
</script>`
      );
    }
  };
};

// ‚úÖ –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ò–ó–í–õ–ï–ß–ï–ù–ò–Ø CRITICAL CSS (–í–´–ù–ï–°–ï–ù–ê –û–¢–î–ï–õ–¨–ù–û)
function extractCriticalCSS(fullCSS) {
  // –ë–∞–∑–æ–≤—ã–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–∏–ª–∏
  let criticalCSS = `/* Critical CSS - Above The Fold Content */
/* Generated automatically during build */

/* Reset and base styles */
* { box-sizing: border-box; }
html { scroll-behavior: smooth; }
body { 
  margin: 0; 
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.5;
}

/* Critical layout components */
header, nav, .header, .navigation, 
.hero, .banner, .first-screen,
h1, h2, h3, .title, .subtitle {
  /* Ensure critical elements are styled */
}

/* Critical typography */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 0.5em;
  line-height: 1.2;
}

/* Critical images */
img { max-width: 100%; height: auto; }

/* Critical buttons and links */
a { color: inherit; text-decoration: none; }
button { cursor: pointer; }

/* Loading states */
.critical-loading { opacity: 0; }
.critical-loaded { opacity: 1; transition: opacity 0.3s ease; }
`;

  // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–∏–ª–∏ –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ CSS
  const criticalPatterns = [
    // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏
    /(\*\{[^}]*\})/g,
    /(html[^{]*\{[^}]*\})/g,
    /(body[^{]*\{[^}]*\})/g,
    
    // –®—Ä–∏—Ñ—Ç—ã
    /(@font-face[^{]*\{[^}]*\})/g,
    
    // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
    /(\.(header|nav|hero|banner|first-screen|logo)[^{]*\{[^}]*\})/g,
    /(\.(btn|button|primary|main)[^{]*\{[^}]*\})/g,
    /(\.(title|heading|h[1-6])[^{]*\{[^}]*\})/g,
    
    // –ú–µ–¥–∏–∞-–∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
    /(@media[^{]*\{[^}]{1,500}\})/g
  ];

  criticalPatterns.forEach(pattern => {
    const matches = fullCSS.match(pattern);
    if (matches) {
      matches.forEach(match => {
        if (match.length < 800) { // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –ø—Ä–∞–≤–∏–ª
          criticalCSS += '\n' + match + '\n';
        }
      });
    }
  });

  return criticalCSS;
}

// ‚úÖ –ü–õ–ê–ì–ò–ù –î–õ–Ø –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ì–û –°–û–ó–î–ê–ù–ò–Ø CRITICAL CSS –ò –û–¢–õ–û–ñ–ï–ù–ù–û–ô –ó–ê–ì–†–£–ó–ö–ò
const criticalCSSPlugin = () => {
  let isProduction = false;
  
  return {
    name: 'critical-css-plugin',
    
    config(config, { command }) {
      isProduction = command === 'build';
    },
    
    transformIndexHtml(html) {
      if (!isProduction) return html;
      
      console.log('üéØ Injecting critical CSS optimization...');
      
      // –°–æ–∑–¥–∞–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ CSS
      const optimizedHTML = html
        .replace(
          /<link rel="stylesheet" href="(.*?main.*?\.css)">/g,
          `<!-- Critical CSS Optimization -->
<style>
/* Critical CSS will be inlined during build process */
/* Base critical styles for above-the-fold content */
.critical-hidden { opacity: 0; }
.critical-visible { opacity: 1; transition: opacity 0.3s ease-in-out; }
</style>

<!-- Preload critical resources -->
<link rel="preload" href="$1" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="$1"></noscript>

<!-- Load non-critical CSS with smart delay -->
<script>
(function() {
  var loadDeferredStyles = function() {
    var addStylesNode = document.getElementById('deferred-styles');
    var replacement = document.createElement('div');
    replacement.innerHTML = addStylesNode.textContent;
    document.body.appendChild(replacement);
    addStylesNode.parentElement.removeChild(addStylesNode);
  };
  
  var raf = requestAnimationFrame || mozRequestAnimationFrame ||
      webkitRequestAnimationFrame || msRequestAnimationFrame;
  if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
  else window.addEventListener('load', loadDeferredStyles);
})();
</script>

<div id="deferred-styles">
  <link rel="stylesheet" href="$1" media="print" onload="this.media='all'">
</div>`
        )
        .replace(
          /<\/head>/,
          `<!-- CSS Loading State Handler -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Mark critical content as visible
  setTimeout(function() {
    document.body.classList.add('critical-visible');
  }, 50);
  
  // Load full CSS after critical render
  var fullCSS = document.createElement('link');
  fullCSS.rel = 'stylesheet';
  fullCSS.href = '$1';
  fullCSS.onload = function() {
    document.body.classList.add('full-css-loaded');
    // Initialize components that depend on full CSS
    if (typeof window.initLazyComponents === 'function') {
      window.initLazyComponents();
    }
  };
  
  // Load full CSS with smart delay
  setTimeout(function() {
    document.head.appendChild(fullCSS);
  }, 200);
});
</script>
</head>`
        );

      return optimizedHTML;
    },
    
    async generateBundle(options, bundle) {
      if (!isProduction) return;
      
      console.log('üîß Processing CSS for critical optimization...');
      
      // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ CSS —Ñ–∞–π–ª—ã
      const cssFiles = Object.keys(bundle).filter(key => key.endsWith('.css'));
      
      for (const cssFile of cssFiles) {
        const cssAsset = bundle[cssFile];
        const cssContent = cssAsset.source;
        
        // –°–æ–∑–¥–∞–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é CSS –¥–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å—Ç–∏–ª–µ–π
        if (cssFile.includes('main') || cssFile.includes('index')) {
          const criticalCSS = extractCriticalCSS(cssContent);
          
          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π CSS –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π asset
          const criticalFileName = cssFile.replace('.css', '-critical.css');
          this.emitFile({
            type: 'asset',
            fileName: criticalFileName,
            source: criticalCSS
          });
          
          console.log(`‚úÖ Generated critical CSS: ${criticalFileName}`);
        }
      }
    }
  };
};

// –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–ª–∞–≥–∏–Ω –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è dist –≤ docs —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º HTML
const copyDistToDocs = () => {
  return {
    name: 'copy-dist-to-docs',
    apply: 'build',

    async writeBundle() {
      console.log('üìÅ Copying dist to docs...');

      const distDir = path.resolve(__dirname, 'dist');
      const docsDir = path.resolve(__dirname, 'docs');

      if (!fs.existsSync(distDir)) {
        console.log('‚ùå dist directory not found');
        return;
      }

      // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –ø–ª–∞–≥–∏–Ω–æ–≤
      await new Promise(resolve => setTimeout(resolve, 2000));

      if (fs.existsSync(docsDir)) {
        console.log('üóëÔ∏è Cleaning docs directory...');
        fs.rmSync(docsDir, { recursive: true });
      }
      fs.mkdirSync(docsDir, { recursive: true });

      // –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
      const copyRecursiveSync = (src, dest) => {
        if (!fs.existsSync(src)) return;
        
        const stats = fs.statSync(src);
        
        if (stats.isDirectory()) {
          if (!fs.existsSync(dest)) {
            fs.mkdirSync(dest, { recursive: true });
          }
          
          const items = fs.readdirSync(src);
          for (const item of items) {
            if (item === 'html') continue;
            copyRecursiveSync(path.join(src, item), path.join(dest, item));
          }
        } else {
          fs.copyFileSync(src, dest);
        }
      };

      // –ö–æ–ø–∏—Ä—É–µ–º –≤—Å—ë –∏–∑ dist –≤ docs, –∫—Ä–æ–º–µ html –ø–∞–ø–∫–∏
      copyRecursiveSync(distDir, docsDir);
      console.log('‚úÖ Basic structure copied');

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º HTML —Ñ–∞–π–ª—ã –æ—Ç–¥–µ–ª—å–Ω–æ
      const htmlDir = path.join(distDir, 'html');
      if (fs.existsSync(htmlDir)) {
        const htmlFiles = fs.readdirSync(htmlDir).filter(f => f.endsWith('.html'));
        for (const htmlFile of htmlFiles) {
          const srcPath = path.join(htmlDir, htmlFile);
          const destPath = path.join(docsDir, htmlFile);
          
          if (fs.existsSync(srcPath)) {
            fs.copyFileSync(srcPath, destPath);

            console.log(`üîß Fixing HTML quotes in: ${htmlFile}`);
            
            // –ß–∏—Ç–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ HTML —Ñ–∞–π–ª–∞
            let content = fs.readFileSync(destPath, 'utf8');
            
            // 1. –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—É—Ç–∏ –≤ HTML —Ñ–∞–π–ª–∞—Ö
            content = content
              .replace(/(src|href|data-src|srcset)=["']\/(assets|images|files)\//g, '$1="./$2/')
              .replace(/(src|href|data-src|srcset)=["']\.\.\/(assets|images|files)\//g, '$1="./$2/')
              .replace(/(src|href|data-src|srcset)=["']\.(?!\.)\//g, '$1="./');

            // 2. –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–±–ª–µ–º—É —Å –∫–∞–≤—ã—á–∫–∞–º–∏ –≤ picture —Ç–µ–≥–∞—Ö
            content = content.replace(
              /<picture>\s*<source\s+srcset=("|')([^"']+)("|')\s+type=("|')image\/webp("|')\s*>/gi,
              (match, quote1, srcset, quote2, quote3, quote4) => {
                return `<picture><source srcset="${srcset}" type="image/webp">`;
              }
            );

            // –í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥: –∏—Å–ø—Ä–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –∫–∞–≤—ã—á–∫–∏ –≤–æ–æ–±—â–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç
            content = content.replace(
              /<picture>\s*<source\s+srcset=([^\s>]+)\s+type=([^\s>]+)\s*>/gi,
              (match, srcset, type) => {
                const fixedSrcset = srcset.includes('"') ? srcset : `"${srcset}"`;
                const fixedType = type.includes('"') ? type : `"${type}"`;
                return `<picture><source srcset=${fixedSrcset} type=${fixedType}>`;
              }
            );

            // 3. –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–±–ª–µ–º—É —Å mixed quotes –≤ img —Ç–µ–≥–∞—Ö
            content = content.replace(
              /<img([^>]*?)src=("|')([^"']+)("|')([^>]*?)>/gi,
              (match, before, quote1, src, quote2, after) => {
                let fixedAfter = after.replace(/(\w+)=("|')([^"']+)("|')/g, '$1="$3"');
                return `<img${before}src="${src}"${fixedAfter}>`;
              }
            );

            // 4. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –∞—Ç—Ä–∏–±—É—Ç–æ–≤ alt, loading –∏ class
            content = content.replace(
              /<img([^>]*?)alt=("|')([^"']*)("|')([^>]*?)>/gi,
              (match, before, quote1, alt, quote2, after) => {
                return `<img${before}alt="${alt}"${after}>`;
              }
            );

            content = content.replace(
              /<img([^>]*?)loading=("|')([^"']*)("|')([^>]*?)>/gi,
              (match, before, quote1, loading, quote2, after) => {
                return `<img${before}loading="${loading}"${after}>`;
              }
            );

            content = content.replace(
              /<img([^>]*?)class=("|')([^"']*)("|')([^>]*?)>/gi,
              (match, before, quote1, className, quote2, after) => {
                return `<img${before}class="${className}"${after}>`;
              }
            );

            // 5. –ò—Å–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –ø—Ä–æ–±–ª–µ–º—É –∏–∑ –ø—Ä–∏–º–µ—Ä–∞
            content = content.replace(
              /<picture><source srcset=("|')([^"']+)("|') type=("|')image\/webp("|')><img([^>]*?)src=("|')([^"']+)("|')([^>]*?)><\/picture>/gi,
              (match, quote1, webpSrc, quote2, quote3, quote4, imgAttrs, quote5, imgSrc, quote6, imgAfter) => {
                return `<picture><source srcset="${webpSrc}" type="image/webp"><img${imgAttrs}src="${imgSrc}"${imgAfter}></picture>`;
              }
            );

            // 6. –û–±—â–µ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö —Ç–µ–≥–æ–≤ —Å –∞—Ç—Ä–∏–±—É—Ç–∞–º–∏
            content = content.replace(
              /<(\w+)([^>]*?)>/gi,
              (match, tagName, attributes) => {
                if (tagName.toLowerCase() === 'script' || tagName.toLowerCase() === 'style') {
                  return match;
                }
                
                const fixedAttributes = attributes.replace(
                  /(\w+)=("|')([^"']*)("|')/g,
                  '$1="$3"'
                );
                
                return `<${tagName}${fixedAttributes}>`;
              }
            );

            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
            fs.writeFileSync(destPath, content, 'utf8');
            console.log(`‚úÖ Fixed HTML quotes in: ${htmlFile}`);
          }
        }
        console.log(`‚úÖ Copied and fixed ${htmlFiles.length} HTML files to docs root`);
      }

      console.log('‚úÖ dist successfully copied to docs with HTML fixes');
      
      // –î–µ—Ç–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
      console.log('üìÅ Final docs structure:');
      if (fs.existsSync(docsDir)) {
        const items = fs.readdirSync(docsDir);
        console.log('üìã Docs contents:', items);
        
        const imagesDir = path.join(docsDir, 'images');
        if (fs.existsSync(imagesDir)) {
          const images = fs.readdirSync(imagesDir);
          console.log('üñºÔ∏è Images in docs:', images.length, 'files');
        }
      }
    }
  };
};

// –ü–ª–∞–≥–∏–Ω –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —à—Ä–∏—Ñ—Ç–æ–≤
const fontAutoPlugin = () => {
  let lastFontHash = null;

  const getFontDirHash = (fontsDir) => {
    try {
      const files = fs.readdirSync(fontsDir)
        .filter(file => /\.(woff2|woff|ttf|otf)$/i.test(file))
        .sort()
        .map(file => `${file}-${fs.statSync(path.join(fontsDir, file)).mtimeMs}`)
        .join('|');
      return files ? require('crypto').createHash('md5').update(files).digest('hex') : null;
    } catch {
      return null;
    }
  };

  return {
    name: 'font-auto-plugin',

    async buildStart() {
      const fontsDir = path.resolve(__dirname, 'src/files/fonts');
      const cssOutputDir = path.resolve(__dirname, 'src/scss/main');
      const cssFilePath = path.join(cssOutputDir, 'fonts.scss');

      if (!fs.existsSync(fontsDir)) {
        console.log('Fonts directory not found, skipping font generation');
        return;
      }

      if (!fs.existsSync(cssOutputDir)) {
        fs.mkdirSync(cssOutputDir, { recursive: true });
      }

      const currentHash = getFontDirHash(fontsDir);

      if (lastFontHash === currentHash && fs.existsSync(cssFilePath)) {
        console.log('‚úÖ fonts.scss is up to date, skipping regeneration');
        return;
      }

      console.log('üîÑ Fonts changed or first run ‚Äî regenerating fonts.scss');

      try {
        const fontFiles = fs.readdirSync(fontsDir);
        const fontFaceRules = [];
        const fontFamilies = {};

        for (const file of fontFiles) {
          if (/\.(woff2|woff|ttf|otf)$/i.test(file)) {
            const fileName = path.parse(file).name;
            const ext = path.parse(file).ext.slice(1);

            const match = fileName.match(/(.*?)([-_](bold|italic|light|medium|regular|black|extrabold|semibold|thin|extralight))?$/i);
            const familyName = match ? match[1].replace(/[-_]/g, ' ') : fileName;
            const style = match && match[3] ? match[3] : 'regular';

            if (!fontFamilies[familyName]) {
              fontFamilies[familyName] = [];
            }

            fontFamilies[familyName].push({
              file,
              ext,
              style: style.toLowerCase(),
              weight: getFontWeight(style),
              isItalic: style.toLowerCase().includes('italic')
            });
          }
        }

        for (const [family, variants] of Object.entries(fontFamilies)) {
          for (const variant of variants) {
            const fontFaceRule = `
@font-face {
  font-family: '${family}';
  src: url('../../files/fonts/${variant.file}') format('${getFormat(variant.ext)}');
  font-weight: ${variant.weight};
  font-style: ${variant.isItalic ? 'italic' : 'normal'};
  font-display: swap;
}
            `.trim();
            fontFaceRules.push(fontFaceRule);
          }
        }

        if (fontFaceRules.length > 0) {
          const cssContent = `/* Auto-generated font styles */\n${fontFaceRules.join('\n\n')}`;
          fs.writeFileSync(cssFilePath, cssContent);
          console.log(`‚úÖ Generated fonts.scss with ${fontFaceRules.length} @font-face rules`);
          lastFontHash = currentHash;
        } else {
          console.log('‚ùå No font face rules were generated');
        }

      } catch (error) {
        console.error('Error generating font styles:', error);
      }
    }
  };
};

// –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø–ª–∞–≥–∏–Ω –¥–ª—è –∑–∞–º–µ–Ω—ã –∞–ª–∏–∞—Å–æ–≤ –≤ HTML
const aliasHtmlPlugin = () => {
  return {
    name: 'alias-html',
    transformIndexHtml(html) {
      const aliasMap = {
        '@img/': '/images/',
        '@scss/': './scss/',
        '@js/': './js/',
        '@bg/': './img/',
        '@fonts/': './fonts/'
      };
      
      let transformedHtml = html;
      for (const [alias, realPath] of Object.entries(aliasMap)) {
        transformedHtml = transformedHtml.replace(new RegExp(alias, 'g'), realPath);
      }
      
      return transformedHtml;
    },
  };
};

// –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ø–ª–∞–≥–∏–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
const imagesPlugin = () => {
  let isBuild = false;

  return {
    name: 'images-plugin',

    config(config, { command }) {
      isBuild = command === 'build';
    },

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º generateBundle –≤–º–µ—Å—Ç–æ buildStart
    async generateBundle() {
      if (!isBuild) return;

      console.log('üñºÔ∏è Processing images...');
      
      const imagesSrcDir = path.resolve(__dirname, 'src/images');
      const imagesDistDir = path.resolve(__dirname, 'dist/images');
      const webpDistDir = path.join(imagesDistDir, 'webp');

      if (!fs.existsSync(imagesSrcDir)) {
        console.log('üìÅ Images directory not found, skipping image processing');
        return;
      }

      // –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è
      if (!fs.existsSync(imagesDistDir)) {
        fs.mkdirSync(imagesDistDir, { recursive: true });
      }
      if (!fs.existsSync(webpDistDir)) {
        fs.mkdirSync(webpDistDir, { recursive: true });
      }

      try {
        const files = fs.readdirSync(imagesSrcDir);
        let copiedCount = 0;
        let webpCount = 0;

        for (const file of files) {
          const srcPath = path.join(imagesSrcDir, file);
          const distPath = path.join(imagesDistDir, file);

          // –ö–æ–ø–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          if (/\.(jpg|jpeg|png|gif|svg|ico)$/i.test(file)) {
            fs.copyFileSync(srcPath, distPath);
            copiedCount++;
            console.log(`üìÑ Copied: ${file}`);
          }

          // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º WebP –¥–ª—è –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
          if (/\.(jpg|jpeg|png)$/i.test(file)) {
            const webpPath = path.join(webpDistDir, `${path.parse(file).name}.webp`);
            try {
              await sharp(srcPath)
                .webp({ quality: 80, effort: 4 })
                .toFile(webpPath);
              webpCount++;
              console.log(`üé® Created WebP: ${path.parse(file).name}.webp`);
            } catch (error) {
              console.warn(`‚ö†Ô∏è Could not convert ${file} to WebP:`, error.message);
            }
          }
        }

        console.log(`‚úÖ Copied ${copiedCount} original images`);
        console.log(`‚úÖ Generated ${webpCount} WebP images`);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        if (fs.existsSync(imagesDistDir)) {
          const distImages = fs.readdirSync(imagesDistDir);
          console.log('üìã Images in dist:', distImages);
        }
        if (fs.existsSync(webpDistDir)) {
          const webpImages = fs.readdirSync(webpDistDir);
          console.log('üé® WebP images generated:', webpImages.length);
        }
        
      } catch (error) {
        console.error('‚ùå Error processing images:', error);
      }
    }
  };
};

// –ë–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–π –ø–ª–∞–≥–∏–Ω –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
const pictureWebpPlugin = () => {
  let isBuild = false;

  return {
    name: 'picture-webp-plugin',

    config(config, { command }) {
      isBuild = command === 'build';
    },
    
    transformIndexHtml(html) {
      if (!isBuild) {
        return html;
      }

      console.log('üñºÔ∏è Wrapping images in <picture> tags for production...');
      
      // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ img —Ç–µ–≥–æ–≤
      const imgRegex = /<img\b([^>]*?\bsrc\s*=\s*(["'])([^"']+?\.(png|jpe?g|jpg))\2[^>]*?)>/gi;
      
      let result = html;
      let match;
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è
      while ((match = imgRegex.exec(html)) !== null) {
        const fullMatch = match[0];
        const attributes = match[1];
        const quote = match[2];
        const src = match[3];
        
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –≤ picture –∏–ª–∏ –∏–º–µ—é—Ç data-skip-webp
        if (fullMatch.includes('data-skip-webp') || 
            fullMatch.includes('<picture') || 
            html.substring(match.index - 50, match.index).includes('<picture')) {
          continue;
        }
        
        let webpSrc;
        
        if (src.startsWith('/images/')) {
          webpSrc = src.replace('/images/', '/images/webp/').replace(/\.(png|jpe?g|jpg)$/i, '.webp');
        } else if (src.startsWith('images/')) {
          webpSrc = src.replace('images/', 'images/webp/').replace(/\.(png|jpe?g|jpg)$/i, '.webp');
        } else if (src.startsWith('./images/')) {
          webpSrc = src.replace('./images/', './images/webp/').replace(/\.(png|jpe?g|jpg)$/i, '.webp');
        } else {
          const lastSlashIndex = src.lastIndexOf('/');
          if (lastSlashIndex !== -1) {
            const path = src.substring(0, lastSlashIndex);
            const fileName = src.substring(lastSlashIndex + 1);
            const webpFileName = fileName.replace(/\.(png|jpe?g|jpg)$/i, '.webp');
            webpSrc = `${path}/webp/${webpFileName}`;
          } else {
            webpSrc = src.replace(/\.(png|jpe?g|jpg)$/i, '.webp');
          }
        }
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ —Ç–∏–ø –∫–∞–≤—ã—á–µ–∫, —á—Ç–æ –∏ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º —Ç–µ–≥–µ
        const replacement = `<picture><source srcset=${quote}${webpSrc}${quote} type="image/webp">${fullMatch}</picture>`;
        result = result.replace(fullMatch, replacement);
      }
      
      return result;
    }
  };
};

export default defineConfig({
  root: path.resolve(__dirname, 'src'),
  base: './',

  resolve: {
    alias: {
      '@img': path.resolve(__dirname, 'src/images'),
      '@scss': path.resolve(__dirname, 'src/scss'),
      '@js': path.resolve(__dirname, 'src/js'),
      '@bg': path.resolve(__dirname, 'src/img'),
      '@fonts': path.resolve(__dirname, 'src/files/fonts'),
    },
  },

  plugins: [
    fontAutoPlugin(),
    handlebars({
      partialDirectory: path.resolve(__dirname, 'src/html/partials'),
      context: {
        title: {
          index: '–ì–ª–∞–≤–Ω–∞—è',
        },
      },
    }),
    aliasHtmlPlugin(),
    imagesPlugin(),
    pictureWebpPlugin(),
    tailwindcss(),
    
    // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú CRITICAL CSS –ü–õ–ê–ì–ò–ù
    criticalCSSPlugin(),
    simpleAsyncCSSPlugin(),
    copyDistToDocs(),
  ],

  build: {
    rollupOptions: {
      input: rollupInputs,
      output: {
        manualChunks: {
          vendor: ['swiper', 'inputmask'],
        },
        assetFileNames: (assetInfo) => {
          if (assetInfo.name && /\.(woff|woff2|eot|ttf|otf)$/i.test(assetInfo.name)) {
            return `files/fonts/[name][extname]`;
          }
          if (assetInfo.name && /\.(jpg|jpeg|png|gif|svg|ico)$/i.test(assetInfo.name)) {
            return `images/[name][extname]`;
          }
          // –†–∞–∑–¥–µ–ª—è–µ–º CSS —Ñ–∞–π–ª—ã
          if (assetInfo.name && /\.css$/i.test(assetInfo.name)) {
            if (assetInfo.name.includes('critical')) {
              return `assets/critical-[name]-[hash][extname]`;
            }
            return `assets/[name]-[hash][extname]`;
          }
          return `assets/[name]-[hash][extname]`;
        },
        chunkFileNames: 'assets/[name]-[hash].js',
        entryFileNames: 'assets/[name]-[hash].js',
      },
    },
    
    chunkSizeWarningLimit: 1000,
    minify: true,
    sourcemap: false, // –û—Ç–∫–ª—é—á–∞–µ–º –¥–ª—è production
    outDir: path.resolve(__dirname, 'dist'),
    assetsInlineLimit: 4096, // –í–∫–ª—é—á–∞–µ–º –∏–Ω–ª–∞–π–Ω–∏–Ω–≥ –º–µ–ª–∫–∏—Ö —Ñ–∞–π–ª–æ–≤
    emptyOutDir: true,
    
    // ‚úÖ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø CSS
    cssCodeSplit: true,
    cssMinify: true,
  },

  server: {
    open: '/html/index.html',
    watch: {
      ignored: [
        '**/node_modules/**',
        '**/.git/**',
        '**/dist/**',
        '**/docs/**',
        '**/src/files/**',
        '**/src/images/webp/**',
      ],
    },
  },
});

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –æ–±—ä–µ–∫—Ç –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª—è—Ö
export { rollupInputs };